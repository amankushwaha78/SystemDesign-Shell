<!-- 
2. Publisher-Subscriber (Pub/Sub) Model :
-----------------------------------------
The Publisher-Subscriber (Pub/Sub) Model is an asynchronous communication pattern.
where a publisher sends messages to a message broker, and subscribers receive those messages if they are subscribed to the topic. 

Note : The publisher and subscriber do not directly communicate with each other, 
       they don't know about each other,
       making the system loosely coupled and scalable.

What it means :
---------------
👉 Sender doesn’t know who receives the message
    Publisher → Topic → Subscribers

-----------------------------------------------------------
🧩 COMPONENTS:

1️⃣ **Publisher** → Sends messages/events to a topic.  
2️⃣ **Broker / Message Queue System** → Manages and delivers messages.  
3️⃣ **Subscriber** → Receives messages from topics it subscribes to.  
4️⃣ **Topic / Channel** → Logical name where messages are published.

How the Pub/Sub Model Works (Step-by-Step):
-----------------------------------------

a. Publisher Sends Messages :
   A publisher publishes a message to a "topic" in a message broker (e.g., Kafka, RabbitMQ, Google Pub/Sub, Redis Pub/Sub).
   The message broker acts as an intermediary.

b. Message Broker Distributes Messages :
   The broker ensures messages are delivered to all interested subscribers who have subscribed to the topic.
   The publisher does not know who the subscribers are.

c. Subscribers Receive Messages
   Any service (subscriber) that has subscribed to the topic receives the message.
   Multiple subscribers can receive the same message.


                                       ┌──────────────┐
                                       │  Publisher   │
                                       └──────┬───────┘
                                             │
                                       (1) Publishes Message
                                             │
                                             ▼
                                    ┌──────────────────┐
                                    │   Message Broker │  (e.g., Kafka, RabbitMQ)
                                    └──────┬───────────┘
                                          │
                                    (2) Distributes Message to Subscribers
                                          │
                                 ┌────────┴────────┐
                                 │                 │
                              ┌──▼──┐         ┌────▼────┐
                              │Sub 1│🗂️      │  Sub 2  │🗂️  <-- Acts as a Publisher
                              └─────┘         └────┬────┘
                                                   │
                                          (3) Publishes to Another Broker
                                                   │
                                                   ▼
                                    ┌──────────────────┐
                                    │  Message Broker 2 │  (e.g., Another Kafka/RabbitMQ instance)
                                    └──────┬───────────┘
                                          │
                                    (4) Distributes Message to More Subscribers
                                          │
                                 ┌────────┴────────┐
                                 │                 │
                              ┌──▼──┐🗂️       ┌────▼────┐🗂️ <- DB
                              │Sub 3│         │  Sub 4  │
                              └─────┘         └────────┘
                              (5) Processes the Message

Example : Kafka, Redis Pub/Sub, AWS SNS
---------

Real-life analogy :
-----------------   📺 YouTube
a. Creator uploads video
b. Subscribers get notification
c. Creator doesn’t know who watched

Key points
-----------
✅ Loose coupling
✅ Scales well
❌ Harder to debug


Advantages:
✅ 1. Decoupling              – Publishers and subscribers don’t know about each other.
✅ 2. Scalability             – Any new service(subscriber) can be added easily.
✅ 3. Asynchronous Processing – No need to wait for an immediate response.

⚠️ DISADVANTAGES OF PUBLISHER–SUBSCRIBER MODEL
❌ 1. **Message Loss** –  
   If a subscriber is offline or temporarily disconnected,  
   it may miss messages unless the broker supports persistence or replay.

❌ 2. **Message Duplication** –  
   Due to retries or network failures, the same message might be delivered multiple times.  
   Consumers must be **idempotent** (able to handle duplicates safely).

❌ 3. **Message Ordering** –  
   When messages are published by multiple publishers or across partitions,  
   the original order may not be preserved.

❌ 4. **Complex Debugging** –  
   Since communication is asynchronous and indirect,  
   tracing message flow across many services becomes harder.

❌ 5. **Latency / Delays** –  
   If the message broker or consumer queue is overloaded,  
   messages can take longer to reach subscribers.

===========================================================
💡 Quick Note:
Most of these issues can be minimized by:
- Using **persistent brokers** (Kafka, RabbitMQ durable queues)
- Implementing **acknowledgments & retries**
- Designing **idempotent consumers**
- Enabling **monitoring & distributed tracing**
===========================================================
*/


/*
---------------------------------------------------------
💻 Real-World Tech:
- Publisher → Microservice (Order Service)
- Topic → "OrderPlaced"
- Subscriber → Payment Service, Email Service

Flow:
🛒 Order Service → Publishes event “OrderPlaced”
💳 Payment Service → Subscribed to “OrderPlaced” → starts payment
📧 Email Service → Subscribed → sends confirmation email


Best Use Cases:
1. Real-time notifications.
2. Log processing and monitoring.
3. Distributed systems with independent services.
-->