<!-- 
3. Event-Driven Model :
-----------------------
The Event-Driven Model is an asynchronous communication pattern.
where services communicate by emitting and responding to events instead of directly calling each other. 

Note : Events are generated when a change occurs, and other services react to these events without needing to know their source service.

Note : The sender and receiver service do not directly communicate with each other, 
       they don't know about each other,
       making the system loosely coupled and scalable.


What it means :
---------------
ðŸ‘‰ System reacts to events
    Event happens â†’ listeners react

Example :
a. UserPlacedOrder event
b. PaymentService reacts
c. EmailService reacts

Real-life analogy:
----------------- ðŸ”” Doorbell
a. Bell rings
b. Everyone reacts differently

Key points
---------
âœ… Highly scalable
âœ… Async
âŒ Event flow can get confusing

âš ï¸ Important :
--------------
Event-driven systems usually use Pub/Sub under the hood

How the Event-Driven Model Works (Step-by-Step):
-----------------------------------------

1. An event occurs : A user action, system change, or an external trigger (e.g., "Order Placed").
                     The event is sent to an Event Bus.
2. Event Bus (Kafka / RabbitMQ / AWS EventBridge) receives the event &  routes the event to appropriate subscribers..
3. Subscribers listen to the event â€“ Multiple services can consume the event and take independent actions.

Note : Services react asynchronously â€“ Services process the event without blocking each other.

                              â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                              â”‚  Event Source â”‚  (User Action, Sensor, API)
                              â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜
                                    â”‚
                              (1) Generates Event  
                                    â”‚
                                    â–¼
                           â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                           â”‚   Event Broker   â”‚  (Kafka, RabbitMQ, Redis Streams)
                           â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                 â”‚
                           (2) Routes Event to Consumers
                                 â”‚
                        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”
                        â”‚                 â”‚
                     â”Œâ”€â”€â–¼â”€â”€â”ðŸ—‚ï¸+ðŸ“š   â”Œâ”€â”€â”€â”€â–¼â”€â”€â”€â”€â”ðŸ—‚ï¸+ðŸ“š  
                     â”‚Svc 1â”‚         â”‚  Svc 2  â”‚    <-- Acts as an Event Producer
                     â””â”€â”€â”€â”€â”€â”˜         â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”˜
                                          â”‚
                                 (3) Produces New Event
                                          â”‚
                                          â–¼
                           â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                           â”‚  Event Broker 2  â”‚  (Chained Event Processing)
                           â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                 â”‚
                           (4) Routes to More Consumers
                                 â”‚
                        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”
                        â”‚                 â”‚
                     â”Œâ”€â”€â–¼â”€â”€â”ðŸ—‚ï¸+ðŸ“š   â”Œâ”€â”€â”€â”€â–¼â”€â”€â”€â”€â”ðŸ—‚ï¸+ðŸ“š <------ ðŸ—‚ï¸ (Data of Service) + ðŸ“š ( Data of Event ) 
                     â”‚Svc 3â”‚         â”‚  Svc 4  â”‚       So we are saving data of own + data coming from another service
                     â””â”€â”€â”€â”€â”€â”˜         â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                     (5) Processes Event and Stores Data



Main Advantage of EVent-Driven Model :
------------------------------------

âœ… 1. **Data Consistency & Resilience**
   Each service keeps its own copy of relevant data.
   â†’ If one service fails or its DB changes, others are unaffected.

âœ… 2. **Decoupled & Scalable**
   Producers and consumers donâ€™t depend on each other.
   â†’ You can add new consumers without changing publishers.

âœ… 3. **Event Replay & History**
   Stored events can be replayed later to rebuild state or recover.

âœ… 4. **Real-Time Responsiveness**
   Services react instantly to new events.

âœ… 5. **Transaction Guarantee**
   Either an event succeeds or fails completely (0/1 behavior).


Disadvantages:
--------------
âŒ 1. **Event Ordering Complexity**
   Hard to maintain sequence across multiple producers.

âŒ 2. **Difficult Debugging**
   Tracing an event through multiple async services is tricky.

âŒ 3. **High Resource Usage**
   Requires brokers, queues, handlers, and consumes CPU for event logic.

âŒ 4. **Latency**
   Multi-layer asynchronous flow may cause slight delays.

âŒ 5. **Access Control**
   Restricting specific services from consuming certain events
   needs extra configuration or custom filtering logic.


Best Use Cases:
1. Real-time data processing.
2. Microservices communication.
3. IoT and sensor-driven applications.


ðŸ INTERVIEW SUMMARY
-----------------------------------------------------------
ðŸ’¬ â€œIn Event-Driven Architecture, services emit and react to events 
asynchronously through an event bus (Kafka/RabbitMQ).  
It makes systems scalable and loosely coupled but introduces challenges 
like ordering, debugging, and latency.â€
===========================================================
-->
                                                                

<!-- 
Event-driven => Publish event when someone needs to know something. SO they pulish events.
Req/Response => Service ask for something (May be for data or something) 

Event-driven Model also uses Pubsher/Subscriber Model.
-->